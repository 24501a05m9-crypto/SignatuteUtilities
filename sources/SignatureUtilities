module hemanth_addr::signature_utils {
    use std::vector;
    use std::signer;
    use aptos_framework::account;
    use aptos_std::ed25519;
    use aptos_std::multi_ed25519;

    /// Error codes
    const E_INVALID_SIGNATURE: u64 = 1;
    const E_INVALID_PUBLIC_KEY: u64 = 2;

    /// Struct to store signature data
    struct SignatureData has key, store {
        message: vector<u8>,
        signature: vector<u8>,
        public_key: vector<u8>,
        is_verified: bool,
    }

    /// Function 1: Store signature data for verification
    public fun store_signature_data(
        account: &signer,
        message: vector<u8>,
        signature: vector<u8>,
        public_key: vector<u8>
    ) {
        let account_addr = signer::address_of(account);
        
        // Verify the signature before storing
        let is_valid = verify_ed25519_signature(
            &message,
            &public_key,
            &signature
        );

        let sig_data = SignatureData {
            message,
            signature,
            public_key,
            is_verified: is_valid,
        };

        // Store or update signature data
        if (exists<SignatureData>(account_addr)) {
            let stored_data = borrow_global_mut<SignatureData>(account_addr);
            *stored_data = sig_data;
        } else {
            move_to(account, sig_data);
        }
    }

    /// Function 2: Verify signature and return validation status
    public fun verify_signature_data(account_addr: address): bool acquires SignatureData {
        assert!(exists<SignatureData>(account_addr), E_INVALID_SIGNATURE);
        
        let sig_data = borrow_global<SignatureData>(account_addr);
        
        // Re-verify the signature
        verify_ed25519_signature(
            &sig_data.message,
            &sig_data.public_key,
            &sig_data.signature
        )
    }

    /// Helper function for ED25519 signature verification
    fun verify_ed25519_signature(
        message: &vector<u8>,
        public_key: &vector<u8>,
        signature: &vector<u8>
    ): bool {
        let pk = ed25519::new_unvalidated_public_key_from_bytes(*public_key);
        let sig = ed25519::new_signature_from_bytes(*signature);
        ed25519::signature_verify_strict(&sig, &pk, *message)
    }
}